
ES6
1.let声明的变量只在它所在的代码块有效;
2.只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
3.使用let声明变量必须先声明在使用否则ReferenceError；
4.let不允许在相同作用域内，重复声明同一个变量;
5.暂时性死区 let const 语句不会出现变量的提升，（为了防止在运行时减少报错，防止变量在未声明前就使用这个变量。）；
6.暂时性死区的本质：
只要一进入当前作用域，所要使用的变量就已经存在了，
但是不可获取，只有等到声明变量的那一行代码出现，
才可以获取和使用该变量。
7.let 不允许在同一作用域内重复声明一个变量；
8.作用域：
.ES5只有全局作用域和函数作用域，没有块级作用域；
.内层变量可能会覆盖外层变量。
.用来计数的循环变量泄露为全局变量。
.ES6允许块级作用域任意嵌套；
.允许在块级作用域之中声明函数，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
.允许在块级作用域内声明函数。
.函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
.同时，函数声明还会提升到所在的块级作用域的头部。
.ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域；
9.const
.const声明一个只读的常量。一旦声明，常量的值就不能改变。
.const一旦声明变量，就必须立即初始化，不能留到以后赋值。
.const的作用域与let命令相同：只在声明所在的块级作用域内有效。
const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
.const声明的常量，也与let一样不可重复声明。
10.ES6 六种变量声明方法；
.ES5 中只有两种var命令和function命令
.ES6 import命令和class命令，let命令和const命令
